# Замыкания
# 1
# Внутри функции можно объявлять другие функции:
# Главная функция
def main_func():
    # Вложенная функция
    def inner_func():
        # Эта функция только печатает
        print('hello my friend')

    # После определения(выше) - я вызываю ее(функцию)
    inner_func()
    # Теперь, если ее скопипастить и вставить в терминал - вызвать с помощью main_func(), то она напечатает сообщение
    # Однако, эта функция ничего не возвращает. Если присвоить ей значение a = main_func() - я это увижу

# 2
# Теперь я сделаю ключевое изменение. Я буду возвращать вложенную функцию
# Только уберу скобки
def main_func():
    def inner_func():
        print('hello my friend')
    # Убрав скобки я возвращаю саму функцию а не вызываю ее
    return inner_func
# Сохраню результат вызова функции в переменной b = main_func()
# Теперь вызову переменную b и обнаружу, что она и есть функция
# <function main_func.<locals>.inner_func at 0x000001EE77831D80>
# И вызвав переменную b как функцию b() я получу ее действие
# Именно это изменение поможет понять замыкания

# 3
# Для замыкания осталось только добавить переменную:
def main_func():
    name = 'Ivan'
    def inner_func():
        # Новой переменной я буду пользоваться внутри вложенной функции:
        print('hello my friend', name)
    return inner_func
# Теперь стоит понять, что область видимости во вложенной функции - локальная
# Но переменная из главной функции спокойно туда подставиться
# Замыканием именно это и называется -
# Когда функция пользуется переменной. Которая не была объявленна в ее теле

# 4
# Однако после того, как функция отработает - переменная name = 'Ivan' не будет удалена
# И это можно использовать. Например сделать принимающее значение для функции:
def main_func(value):
    name = value
    def inner_func():
        print('hello my friend', name)

    return inner_func
# Теперь я могу передать ей значение и она его сохранит
# Например d = main_func('Misha'). После вызова функции d() name  ней будет всегда Misha
# Можно сделать тоже самое для другой переменной
# Например v = main_func('Vasua'). В этом случае name будет как Vasua
# Теперь каждый такой вызов main_func будет создавать свою область видимости со своими значениями.
# Теперь эта функция связана с этим значением ЗАМЫКАНИЕМ

def main_func(name):
    def inner_func():
        print('hello my friend', name)

    return inner_func

def adder(value):
    def inner(a):
        return value+a
    return inner

def counter():
    count = 0
    def inner():
        nonlocal count
        count +=1
        return count
    return inner

